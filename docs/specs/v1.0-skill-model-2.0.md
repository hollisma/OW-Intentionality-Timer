## V1.0 Spec – Skill Model 2.0 & Organization

### 1. Scope & Goals

**Milestone reference**: This spec corresponds to **V1.0 – Skill Model 2.0 & Organization** in `docs/roadmap.md`.

**High-level goal**: Redesign the local skill model and UI so that:
- Skills can be organized by **hero**, **role**, and **custom categories/tags**.
- The data model is **forward-compatible** with:
  - Multiple games (Overwatch now, other games later).
  - Accounts/cloud sync (V1.3) without major migrations.
  - Progress tracking (V1.1) and playlists (V1.2).
- The UX makes it **easy and fast** to:
  - View skills grouped by hero/role.
  - Filter/sort skills by hero/role/tags.
  - Switch which “set” of skills is active for the upcoming session.

**Non-goals for V1.0 (do not implement yet)**:
- No authentication or remote database (that’s V1.3).
- No progress tracking or ratings (that’s V1.1).
- No playlists/loadouts (that’s V1.2).
- No skill browser or sharing (V1.4–V1.5).

V1.0 is **purely local**, but must be designed so adding accounts later is mostly a **persistence-layer change**, not a major schema/UX rewrite.

---

### 2. Data Model (Domain Layer)

All interfaces here are **TypeScript-style** and describe the **domain model**, not necessarily the exact storage format. The implementation should keep domain models separate from persistence DTOs where useful.

#### 2.1. Core Identifiers

```ts
type GameId = 'overwatch' | string; // allow other games later
type HeroId = string;                // e.g. 'tracer', 'reinhardt'
type RoleId = 'tank' | 'damage' | 'support' | 'flex' | string;
type SkillId = string;               // UUID or stable string id
type CategoryId = string;            // user-defined categories
type TagId = string;                 // free-form tags with normalized keys
```

Implementation notes:
- Use **string IDs everywhere** even if in-memory they are just random `crypto.randomUUID()` values.
- For now, you can hardcode `gameId: 'overwatch'` for all built-in skills and user skills.

#### 2.2. Skill Entity

```ts
interface Skill {
  id: SkillId;
  gameId: GameId;           // always 'overwatch' for now

  name: string;             // short label surfaced in UI
  description: string;      // longer explanation for the user

  ttsText: string;          // what we read out via speechSynthesis
  timerSeconds: number;     // interval for TTS reminders

  heroId?: HeroId | null;   // null = general skill
  roleId?: RoleId | null;   // null = general skill

  categoryIds: CategoryId[]; // user-defined categories (e.g. "Warmup", "Ranked Tank")
  tagIds: TagId[];           // fine-grained tags (e.g. "positioning", "ult-tracking")

  isPreset: boolean;         // true if shipped with the app on first run
  isArchived: boolean;       // soft-delete flag for "removed" skills

  createdAt: string;         // ISO date string
  updatedAt: string;         // ISO date string
}
```

Key points:
- **`isPreset`**:
  - Indicates the **origin** of a skill (shipped with the app vs. user-created), not whether it can be deleted.
  - Users **may delete preset skills** just like user-created skills; deletion behaviour is driven by `isArchived`, not `isPreset`.
  - The flag is mainly for future features like “reset to defaults” or updating the built-in library, and for distinguishing built-in vs. custom skills in the UI if desired.
- **`isArchived`**:
  - When a user “deletes” a skill, we **set `isArchived = true`** instead of hard-deleting it.
  - Archived skills are hidden from normal views; V1.0 does not need a full archive-management UI, but should keep the data so we can support “undo”, future migrations, or a “restore skill” feature later.
  - Archived skills remain in local storage until the user clears app data; a future milestone can add “permanently delete archived skills” if needed.

#### 2.3. Category & Tag Models

```ts
interface Category {
  id: CategoryId;
  name: string;         // user-facing label (e.g. "Warmup")
  gameId: GameId;       // future-proofing; for now 'overwatch'
  createdAt: string;
  updatedAt: string;
}

interface Tag {
  id: TagId;            // e.g. normalized "positioning"
  label: string;        // user-facing label, e.g. "Positioning"
  gameId: GameId;
}
```

Implementation guidance:
- **Tags**:
  - Tags are **shared** between skills and are not managed in a separate “tag settings” UI in V1.0.
  - Adding a tag to a skill should **auto-create** the tag if it doesn’t exist (based on a normalized key).
  - When the last reference to a tag is removed from all skills, it may be **garbage-collected** from the stored `tags` list; users do not need an explicit “delete tag” action.
  - Tags with the same normalized key should **merge** instead of duplicating (e.g. “Positioning” and “positioning” resolve to the same underlying `Tag`).
- **Categories** are user-defined groups; they will matter more when playlists and dashboards are added, but should exist from V1.0 so we don’t need another migration later.

#### 2.4. Hero & Role Metadata (Static)

V1.0 should introduce a **static metadata layer** for heroes and roles, so that skills can refer to heroes/roles by ID.

```ts
interface RoleMeta {
  id: RoleId;
  name: string;        // "Tank", "Damage", "Support"
}

interface HeroMeta {
  id: HeroId;
  name: string;        // "Tracer"
  roleId: RoleId;
}
```

Implementation guidance:
- Store this metadata in a **static TypeScript module** (e.g. `src/data/overwatchHeroes.ts`), not fetched from the network.
- The engineer should expose helper functions like `getHeroById`, `getRoles`, etc., but keep them **pure** and light.

---

### 3. Storage Plan (Local Storage & Versioning)

V0.3 already stores skills in local storage, but we do **not** need to migrate real user data yet. V1.0 should:
- Introduce a **versioned local storage schema** starting at version `"1"`.
- Be designed so that migrating from **local storage → database-backed storage** later is straightforward.
- Keep storage access **thin and isolated** in one module so it’s easy to swap implementations (local vs. remote) behind a common interface.

#### 3.1. Local Storage Keys

Use a small set of well-defined keys under a single namespace:
- `owPractice.v1.skills` – array of serialized skills.
- `owPractice.v1.categories` – array of categories.
- `owPractice.v1.tags` – array of tags.
- `owPractice.v1.settings` – user-local settings (see below).
- `owPractice.schemaVersion` – string, e.g. `"1"`.

Do **not** scatter many different keys; keep everything namespaced so that future account sync can treat this whole “blob” as one document.

#### 3.2. User Settings Schema

For V1.0, the persisted data for skills, categories, and tags can match the domain interfaces (`Skill`, `Category`, `Tag`) directly and be stored as JSON arrays. We **do not** need separate `Persisted*` interfaces yet; those can be introduced in a future schema version if the persistent shape diverges from the in-memory model.

```ts
interface UserSettingsV1 {
  selectedGameId: GameId;           // 'overwatch' for now
  selectedRoleId: RoleId | null;
  selectedHeroId: HeroId | null;

  // list preferences
  sortBy: 'name' | 'role' | 'hero' | 'createdAt';
  sortDirection: 'asc' | 'desc';

  // default filters
  filterRoleIds: RoleId[];
  filterHeroIds: HeroId[];
  filterCategoryIds: CategoryId[];
  filterTagIds: TagId[];
}
```

Implementation guidance:
- When loading data, read the raw JSON into `Skill[]`, `Category[]`, `Tag[]`, and `UserSettingsV1` and treat them as the in-memory domain model for V1.0.
- Always wrap `localStorage` access in **try/catch** and provide a reasonable fallback (empty arrays, default settings).

#### 3.3. Schema Version & Migration

On app startup:
1. Read `owPractice.schemaVersion`.
2. If absent, assume **V0.x** schema and run a migration.
3. After successful migration, write `schemaVersion = "1"` and store data under `owPractice.v1.*` keys.

Migration rules from V0.x (approximate):
- Old skills likely have fields: `{ id, description, ttsText, timerSeconds, ... }` without hero/role/game/categories/tags.
- For each legacy skill:
  - Set `gameId = 'overwatch'`.
  - Set `name` to a sane value (e.g. re-use old title or derive from description; if not available, use `"Skill N"` format).
  - Set `heroId = null`, `roleId = null`.
  - Set empty arrays for `categoryIds` and `tagIds`.
  - Set `isPreset` based on whether it came from default presets vs. user-created (if that information exists; otherwise default to `false`).
  - Set `isArchived = false`.
  - Add `createdAt` and `updatedAt` as current timestamp strings for all imported skills.

The migration should run **once**, and if anything fails, it should **fall back** to the old behaviour instead of breaking the app (e.g. show a warning and keep in-memory defaults).

> **Note for V1.0**: The above V0.x → V1.0 migration rules are an example only and **should not be implemented** for this milestone. For V1.0, treat schema version `"1"` as the first stable schema:
> - On startup, if `owPractice.schemaVersion === "1"`, load data from `owPractice.v1.*` keys.
> - If `schemaVersion` is missing or anything else, treat this as **no persisted data**, start with built-in presets and default settings, and write `schemaVersion = "1"` on first save.
> - Future schema changes (e.g. moving to a database) must provide explicit migration logic **from version "1"** to the new version.

---

### 4. React Component Structure (High-Level)

This section defines **components and responsibilities**, not implementation code. The engineer should follow these responsibilities and prop contracts to avoid mixing concerns.

#### 4.1. Top-Level State & Context

Introduce a **`SkillStore`** layer to keep skill-related state and actions in one place. This can be implemented with React Context or a small store library, but the architecture is:

```ts
interface SkillStoreState {
  skills: Skill[];
  categories: Category[];
  tags: Tag[];
  settings: UserSettingsV1;

  isLoading: boolean;
  loadError: string | null;
}

interface SkillStoreActions {
  loadFromStorage(): Promise<void>;
  addSkill(input: NewSkillInput): void;
  updateSkill(id: SkillId, patch: Partial<Skill>): void;
  archiveSkill(id: SkillId): void;

  addCategory(name: string): void;
  renameCategory(id: CategoryId, name: string): void;
  deleteCategory(id: CategoryId): void; // removes this categoryId from all skills

  updateSettings(patch: Partial<UserSettingsV1>): void;
}

type NewSkillInput = Omit<Skill, 'id' | 'createdAt' | 'updatedAt' | 'isArchived' | 'isPreset'>;
```

Implementation guidance:
- All **business logic** (e.g. how to assign IDs, how to archive, how to write to local storage) should live in the store or its helpers, **not** in presentational components.
- UI components should receive data and callbacks via props (or hooks) and avoid direct `localStorage` calls.
 - To avoid unnecessary re-renders, prefer **selector hooks** (e.g. `useSkillStore(selector)`) or split contexts (e.g. one for data, one for actions) rather than having every component subscribe to the entire `SkillStoreState`.

#### 4.2. Component List & Responsibilities

**Note**: Names are suggestions; the engineer can use close variations as long as responsibilities are preserved.

- **`SkillLayout`**
  - Layout component for the “Skills” part of the app.
  - Renders filters/sidebar + main skill list + editor panel.
  - Connects to `SkillStore` via context/hook and passes data down.

- **`SkillFiltersPanel`**
  - Shows hero/role filters, category filters, tag filters.
  - Props (conceptually):
    - `roles: RoleMeta[]`
    - `heroes: HeroMeta[]`
    - `categories: Category[]`
    - `tags: Tag[]`
    - `settings: UserSettingsV1`
    - Callbacks like `onChangeRoleFilter`, `onChangeHeroFilter`, `onChangeCategoryFilter`, `onChangeTagFilter`, `onChangeSort`.
  - Contains **no storage logic**; just calls callbacks.

- **`SkillList`**
  - Receives a **pre-filtered & sorted** list of `Skill` objects (to keep it as dumb as possible).
  - Props:
    - `skills: Skill[]`
    - `onSelectSkill(id: SkillId): void`
    - `selectedSkillId: SkillId | null`
  - Responsible only for rendering list items and highlighting the selected skill.

- **`SkillListItem`**
  - Renders an individual skill row in the list.
  - Shows name, hero/role, key tags, maybe preset badge.
  - Props:
    - `skill: Skill`
    - `isSelected: boolean`
    - `onClick(): void`

- **`SkillEditor`**
  - Existing component can be extended/refined.
  - Props:
    - `skill: Skill | null` (null when creating a new skill).
    - `heroes: HeroMeta[]`
    - `roles: RoleMeta[]`
    - `categories: Category[]`
    - `onSave(skillInput: NewSkillInput | Partial<Skill>): void`
    - `onArchive?(id: SkillId): void`
  - Handles form inputs for:
    - name, description
    - ttsText, timerSeconds
    - hero, role
    - categories and tags (prefer tag picker UI)
  - Performs **local validation only**; error display is handled inside.

- **`CategoryManager` (optional, can be inline in editor or in a dialog)**
  - UI for creating/renaming/deleting categories.
  - Uses `SkillStoreActions` for persistence.

#### 4.3. Derived Selectors & Filtering Logic

To keep components simple and avoid duplicated logic, provide selectors or pure helper functions in a separate module, for example `src/logic/skillSelectors.ts`:

```ts
interface SkillFilterCriteria {
  roleIds?: RoleId[];
  heroIds?: HeroId[];
  categoryIds?: CategoryId[];
  tagIds?: TagId[];
  searchQuery?: string;
}

type SkillSortKey = 'name' | 'role' | 'hero' | 'createdAt';

function filterAndSortSkills(
  skills: Skill[],
  criteria: SkillFilterCriteria,
  sortKey: SkillSortKey,
  sortDirection: 'asc' | 'desc'
): Skill[];
```

Implementation guidance:
- This function should be **pure** (no side-effects, no I/O).
- The UI should **not** re-implement filter/sort logic; always use the shared selector.

---

### 5. UX Behaviour Details

To avoid ambiguity for a junior engineer, this section spells out specific behaviours.

#### 5.1. Default Filters & Selection

- On first launch (no stored settings):
  - Default to **all roles** and **all heroes** selected.
  - No category or tag filters applied.
  - Sort by `name` ascending.
- When a user changes filters or sort options:
  - Immediately update the list.
  - Persist the new `UserSettingsV1` to local storage (debounced is fine but not required for V1.0).

#### 5.2. Skill Creation & Editing

- **Creating a new skill**:
  - Start with `gameId = 'overwatch'`.
  - Pre-fill `heroId` and `roleId` from the current filters if there is a single value selected; otherwise leave them null.
  - New skills are `isPreset = false`, `isArchived = false`.
  - `createdAt` and `updatedAt` should be set to the current time (ISO string).
- **Editing an existing skill**:
  - Form updates should not write to storage on every keystroke; only on explicit “Save” or when leaving the editor (implementation choice, but be consistent).
  - `updatedAt` should be updated on every successful save.

#### 5.3. Archiving vs Deleting

- Do **not** hard-delete skills in V1.0.
- When a user “removes” a skill from their list:
  - Set `isArchived = true`.
  - Hide archived skills from the main list by default.
  - Optionally offer a filter/toggle to show archived skills for debugging or restoration.

This preserves data for:
- Future migrations.
- Potential “undo” features.

#### 5.4. First-Run Behaviour & Preset Failures

- On a normal first run:
  - Load the built-in preset skills into the local store so the user immediately has useful examples.
- If loading built-in presets fails for any reason (bug, corrupted bundle, etc.):
  - Fall back to an **empty skill list** but keep the app functional (the user can still create their own skills).

---

### 6. Performance & Overwatch Safety Considerations

Although V1.0 is not computationally heavy, follow these guidelines:
- **No heavy computations** in render paths:
  - Filtering and sorting a few hundred skills in memory is fine, but avoid nested expensive operations or unnecessary re-renders.
  - Use memoization (`useMemo`/`useCallback`) where it meaningfully reduces repeat work.
- **Local storage I/O**:
  - Perform reads **once** on startup and cache results in React state.
  - Writes can be done inline on updates; they are fast and infrequent. If you later batch/debounce, keep the interface the same.
- **No Web Workers are required for V1.0**, but the design should avoid blocking the main thread with expensive loops or JSON operations.
 - Design filtering/sorting to be efficient up to at least a few hundred skills and tags. If we ever observe performance issues at that scale, we can move heavier work into a Web Worker in a later version.

If in doubt, remember the priority: **Overwatch FPS should never stutter because of this app**.

---

### 7. Error Handling & Edge Cases

It’s important not to ignore errors silently:
- On load:
  - If parsing local storage fails, log an error (in dev) and fall back to in-memory defaults instead of crashing.
  - Do not show cryptic errors to the end-user; prefer a subtle “data may have been reset” message if needed.
- On save:
  - Wrap `localStorage.setItem` in `try/catch` in case storage quota is exceeded; if that happens, log gracefully.

Edge cases to handle explicitly:
- Skills with missing or unknown `heroId`/`roleId`:
  - Treat as “General” skills; do not crash filtering logic.
- Empty lists (no skills after filters):
  - Show a friendly “No skills match your filters” state with a prompt to create/add skills.
 - Partially corrupted or outdated `UserSettingsV1`:
   - If any settings field is invalid or missing (e.g. an unknown `sortBy` value), fall back to the documented default for that field (e.g. `sortBy: 'name'`) instead of crashing.

---

### 8. Summary for Implementation

For the engineer implementing V1.0:
- **Follow the interfaces and responsibilities** in this spec; if you need to diverge, update this document first.
- Keep **data loading/saving** in a dedicated module (e.g. `src/storage/skillsStorage.ts`).
- Keep **domain logic** (filtering, sorting, archiving) in shared helpers/selectors, not scattered across components.
- Components should be **small and focused**: filters panel, list, list item, editor, category manager, layout.

If any requirement here conflicts with existing code, prefer **updating the old code to match this spec**, not the other way around, and note the change in the next architecture/documentation pass.

