# V1.0.5 Spec – Responsive Layout & Desktop Space Efficiency

## 1. Scope & Goals

**Milestone reference**: This spec corresponds to **V1.0.5 – Responsive Layout & Desktop Space Efficiency** in `docs/roadmap.md`.

**High-level goal**: Revamp the UI so the app feels **space-efficient on desktop** while remaining **mobile-first and fully responsive** across all screen sizes. The layout system must be **extensible** so future page types (home, profile, skills browser) can reuse the same responsive patterns without duplicating logic.

**User experience goals**:
- **Desktop/second-screen users**: See timer, controls, and skill details side-by-side—no constant scrolling or context switching.
- **Mobile users**: Preserve the current stacked, single-column flow; no regression in usability.
- **Transitions**: Layout changes at breakpoints should feel smooth—no jarring jumps or content flicker.
- **Perceived performance**: Layout should respond instantly to viewport changes; avoid JS-driven resize logic that could cause frame drops during Overwatch.

**Non-goals for V1.0.5**:
- No routing or multi-page navigation (that comes with V1.4 Skills Browser).
- No collapsible/resizable panels (optional polish; can be deferred).
- No user preference for layout (e.g. "prefer stacked on desktop")—we use viewport-based breakpoints only.

---

## 2. Architecture Principles

### 2.1. Extensibility for Future Pages

The app will eventually have multiple page types:
- **Practice/Skills page** (current): Timer + filters + skill list + skill editor.
- **Home page** (future): Landing, quick actions, recent activity.
- **Profile page** (future): User stats, settings, preferences.
- **Skills Browser page** (V1.4): Catalog browse + import.

Each may have different content but **similar responsive behavior**:
- Mobile: single column, stacked content.
- Tablet: optional two-column for dense content.
- Desktop: split-panel or sidebar + main content.

**Design decision**: Introduce a **layout abstraction layer** that:
- Defines breakpoints and layout tokens in one place.
- Provides reusable layout components (`AppShell`, `SplitPanel`, `StackedContent`) that accept **slots** (header, primary, secondary).
- Allows each page to compose its content into these slots without reimplementing breakpoint logic.

### 2.2. CSS-First, No Layout Thrashing

- **All responsive behavior** must be driven by **CSS** (flexbox, grid, media queries).
- **Avoid** JS-based layout decisions (e.g. `window.innerWidth` in React state) for breakpoint detection—use CSS `@media` and container queries instead.
- **Avoid** layout thrashing: no `getBoundingClientRect` or `offsetHeight` reads in render or effect loops.
- Resize/reflow must not cause main-thread jank during Overwatch; preference CSS `transform` and `opacity` for any animations if needed.

### 2.3. Progressive Enhancement

- Start with **mobile layout** as the default (no media queries required for base state).
- Add **tablet** and **desktop** layouts via `min-width` media queries—never assume a minimum desktop width for core functionality.

---

## 3. Breakpoints & Layout Tokens

### 3.1. Breakpoint Definitions

Define breakpoints in a single source of truth. Use Tailwind's default breakpoints if they align; otherwise extend via CSS variables or a shared config.

| Name   | Min width | Use case                                      |
|--------|-----------|-----------------------------------------------|
| `base` | 0         | Mobile—single column, stacked.                |
| `md`   | 768px     | Tablet—optional two-column for dense content. |
| `lg`   | 1024px    | Desktop—split-panel layout.                   |

**Implementation**: Use Tailwind classes `md:` and `lg:` (default 768px and 1024px). If a custom config exists, align these values. No JS constants for breakpoints—rely on CSS.

### 3.2. Layout Tokens (CSS Variables)

Introduce optional layout tokens for consistency and future theming:

```css
/* In index.css or a layout module */
:root {
  --layout-breakpoint-tablet: 768px;
  --layout-breakpoint-desktop: 1024px;
  --layout-panel-gap: 1.5rem;        /* gap between split panels */
  --layout-content-max-width: 72rem;  /* max-width for centered content */
  --layout-panel-min-width: 20rem;    /* min width for each panel on desktop */
}
```

These are **optional**; Tailwind utilities can suffice. Include only if they improve maintainability.

---

## 4. Layout Component Architecture

### 4.1. Component Hierarchy

```
App
└── AppShell (or AppLayout)
    ├── Header (optional; currently inline in App)
    └── MainContent
        ├── [Mobile] StackedContent (vertical stack)
        │   ├── Slot: Timer
        │   ├── Slot: Controls (Settings + Filters + SkillList)
        │   └── Slot: Detail (SkillEditor)
        └── [Desktop lg:] SplitPanel
            ├── PrimaryPanel (left, ~40% or min-width)
            │   ├── Slot: Timer
            │   └── Slot: Controls (Settings + Filters + SkillList)
            └── SecondaryPanel (right, ~60%)
                └── Slot: Detail (SkillEditor)
```

### 4.2. AppShell (App-Level Layout Wrapper)

**Purpose**: Provides the outer container, max-width, and responsive padding. Shared across all future pages.

**Responsibility**:
- `min-h-screen`, `w-screen`, scrollable container.
- Centered content with `max-w-*` that grows at `lg:`.
- Consistent horizontal padding (`px-4` mobile, `px-6` desktop).
- No layout logic—just structure.

**Props** (conceptual):
- `children: ReactNode`
- Optional `maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | 'full'` for different page width needs.

**Implementation note**: This can be a thin wrapper; the main responsive logic lives in the content layout below.

### 4.3. PracticePageLayout (Page-Specific Layout)

**Purpose**: Encapsulates the responsive layout for the **Practice/Skills page** (current app content). This component will be the template for the current single-page app; future pages (Home, Profile, Browser) will have their own layout components that use the same breakpoint patterns.

**Structure**:
- **Mobile/base**: Single column. Order: Timer → (Settings + Filters + SkillList) → SkillEditor.
- **Desktop (lg:)**: Two panels side-by-side.
  - **Left (Primary)**: Timer + Settings + Filters + SkillList. Acts as the "control center."
  - **Right (Secondary)**: SkillEditor (skill info, description, details).

**Key behavior**:
- Use CSS Grid or Flexbox with `flex-direction: column` on mobile and `flex-direction: row` at `lg:`.
- Panels should have `min-height` or `flex: 1` so both sides feel substantial on desktop.
- Right panel can scroll independently if content overflows (`overflow-y-auto` on the detail panel).

**Implementation**:
- One component: `PracticePageLayout` (or `SkillsPageLayout`).
- Receives children as **slots** via props or named children:
  - `timerSlot`
  - `controlsSlot` (Settings + Filters + SkillList)
  - `detailSlot` (SkillEditor)
- Renders them in the correct order for each breakpoint.

### 4.4. Splitting Logic

**Option A – Single component with slots**:
```tsx
<PracticePageLayout
  timerSlot={<TimerCard ... />}
  controlsSlot={<ControlsCard ... />}
  detailSlot={<SkillEditorCard ... />}
/>
```

**Option B – Composition with wrapper components**:
```tsx
<PracticePageLayout>
  <PracticePageLayout.Timer>...</PracticePageLayout.Timer>
  <PracticePageLayout.Controls>...</PracticePageLayout.Controls>
  <PracticePageLayout.Detail>...</PracticePageLayout.Detail>
</PracticePageLayout>
```

Either approach is fine. The engineer should choose based on what keeps `App.tsx` clean and avoids prop drilling.

---

## 5. Desktop Split-Panel Layout Details

### 5.1. Panel Sizing

| Panel    | Approx. width | Rationale                                      |
|----------|---------------|------------------------------------------------|
| Primary  | 40% or min 20rem | Timer + controls fit; skill list scrolls.  |
| Secondary| 60% or flex 1 | Skill editor has more room for description, tags. |

**Implementation**:
- Use `grid-cols-[minmax(20rem,2fr)_minmax(24rem,3fr)]` or equivalent.
- Or: `flex` with `flex: 2` left and `flex: 3` right, with `min-width` on both.
- Ensure neither panel shrinks below ~320px (readable content).

### 5.2. Panel Scrolling

- **Primary panel**: If content (timer + filters + list) exceeds viewport height, it should scroll. Use `overflow-y-auto` with `max-h-screen` or `min-h-0` in a flex child to enable scrolling.
- **Secondary panel**: Same—scroll the SkillEditor content independently.
- **Whole page**: On mobile, the whole page scrolls as today. No nested scroll regions needed on mobile.

### 5.3. Optional: Collapsible Secondary Panel (Deferred)

The roadmap mentions: *"If space allows, a collapsible right panel could maximize timer visibility."*

- **V1.0.5**: Not required. Implement only if time permits.
- **If implemented**: A toggle button to show/hide the right panel. State can be in React (e.g. `detailPanelOpen`). Use CSS `width: 0` / `overflow: hidden` when collapsed, with a smooth transition. No animation during resize if it risks jank—instant collapse is acceptable.

---

## 6. Mobile Layout Preservation

### 6.1. Current Behavior (Do Not Regress)

- Single column, full width (bounded by `max-w-lg` today).
- Order: Timer → Editor → Settings+Filters+List.
- All content stacks vertically.
- User scrolls the page to see everything.

### 6.2. V1.0.5 Adjustments

- **Remove or relax** `max-w-lg` on mobile so the app uses full width on small screens (with padding). The current `max-w-lg` may feel narrow on larger phones; consider `max-w-full` on mobile and only apply max-width at `lg:` for the split layout.
- **Order**: Keep Timer → Controls → Detail. The "controls" (Settings + Filters + SkillList) are the primary interaction; the SkillEditor is "detail" for the selected skill. This order matches the desktop mental model (primary left, detail right) when transposed to vertical.

### 6.3. Tablet (768px – 1023px)

- **Default**: Same as mobile—single column. No need for a distinct tablet layout in V1.0.5.
- **Optional**: If the engineer finds that two columns (e.g. list + detail) work well at 768px, they may add a tablet breakpoint. This is **optional** and should not add complexity; prefer simplicity.

---

## 7. UX Behaviour Details

### 7.1. Transitions Between Breakpoints

- **No transition** on initial load—render the correct layout for the current viewport.
- **On resize**: Layout should reflow immediately via CSS. No JS resize listener required.
- **Avoid**: Flicker or content jump. Ensure no component mounts/unmounts based on breakpoint if it would cause a flash. Use CSS `display`, `flex-direction`, `grid-template-columns`—not conditional rendering—for layout changes.

### 7.2. Empty State for Detail Panel

- When **no skill is selected**:
  - **Mobile**: Show the "No skills available" or "Select a skill" message in the detail slot.
  - **Desktop**: Same message in the right panel. The panel should still render (e.g. placeholder or empty state) so the layout doesn't collapse. Consider a subtle "Select a skill from the list" prompt with visual consistency.

### 7.3. Timer Visibility

- Timer is **always** in the primary/control area (top on mobile, left on desktop).
- It should be highly visible—large, contrasting. No change to timer styling; just ensure it remains in the primary slot.

### 7.4. Focus & Keyboard

- No new keyboard shortcuts required for V1.0.5.
- Ensure focus order remains logical when tabbing: Timer → Settings → Filters → List → Detail.

---

## 8. File Structure & Implementation Plan

### 8.1. New Files

| Path | Purpose |
|------|---------|
| `src/components/layout/AppShell.tsx` | Outer layout wrapper; responsive padding, max-width. |
| `src/components/layout/PracticePageLayout.tsx` | Page-specific layout: stacked on mobile, split on desktop. |
| `src/styles/layout.css` (optional) | Layout tokens (CSS variables) if used. |

### 8.2. Modified Files

| Path | Changes |
|------|---------|
| `src/App.tsx` | Use `AppShell` and `PracticePageLayout`; pass current content as slots. Refactor from one big `div` to composition. |
| `src/index.css` | Optionally add layout tokens. |

### 8.3. No Changes Required

- `SkillEditor`, `SkillList`, `SkillFiltersPanel`, `Settings`—these remain presentational. They receive the same props; only their **container** changes.
- Storage, hooks, stores—unchanged.

---

## 9. Performance & Overwatch Safety

### 9.1. CSS-Only Responsiveness

- Use `@media (min-width: ...)` and Tailwind responsive classes.
- **No** `useEffect` + `window.matchMedia` for layout decisions. If a component truly needs to know the breakpoint (e.g. for analytics or a one-off), use `matchMedia` sparingly and ensure it doesn't run during render.

### 9.2. No Layout Thrashing

- Avoid reading layout properties (`offsetWidth`, `getBoundingClientRect`) in render or in effects that run frequently.
- Resize observers are not needed for this feature.

### 9.3. Minimal Re-renders

- Layout components should be mostly structural. They receive slots as children; re-renders happen when parent state changes, which is expected. No additional optimizations required unless profiling shows issues.

---

## 10. Testing & Validation

### 10.1. Manual Checks

- [ ] **Mobile (375px)**: Single column, scrollable, all content accessible. No horizontal overflow.
- [ ] **Tablet (768px)**: Layout still stacked (or two-column if implemented). Readable.
- [ ] **Desktop (1024px)**: Split panel. Left: timer + controls. Right: skill editor. Both panels scroll independently if content overflows.
- [ ] **Desktop (1440px)**: Layout scales; content doesn't stretch awkwardly. Max-width constrains if used.
- [ ] **Resize**: Drag browser from 1440px to 375px. Layout reflows smoothly at breakpoints. No flicker.
- [ ] **No skill selected**: Placeholder in detail panel. Layout intact.

### 10.2. Edge Cases

- Very narrow viewport (320px): Content remains usable; no overlap.
- Very wide viewport (2560px): Content centered or max-width applied; no ultra-wide single column.

---

## 11. Future Extensibility Notes

When adding **Home**, **Profile**, or **Skills Browser** pages:

1. **Reuse `AppShell`** for outer structure.
2. **Create page-specific layout components** (e.g. `HomePageLayout`, `ProfilePageLayout`, `BrowserPageLayout`) that follow the same pattern:
   - Mobile: stacked.
   - Desktop: split or sidebar + main, as appropriate.
3. **Share breakpoint tokens** (Tailwind or CSS vars) so all pages stay consistent.
4. **Consider** a generic `SplitPanel` component that accepts `primary` and `secondary` slots—`PracticePageLayout` would use it; future pages can too with different content.

Example for a future Skills Browser page:
- Mobile: Search/filters → Result list → Detail (when selected).
- Desktop: Left = filters + list; Right = skill detail for import.

The same `SplitPanel` or `PracticePageLayout`-like structure applies.

---

## 12. Summary for Implementation

For the engineer implementing V1.0.5:

1. **Introduce `AppShell`**—thin wrapper for max-width and padding.
2. **Introduce `PracticePageLayout`**—handles stacked vs. split layout via CSS (flex/grid + `lg:` breakpoint).
3. **Refactor `App.tsx`**—compose content into slots; no layout logic in App.
4. **Preserve mobile**—single column, same vertical order.
5. **Desktop**—two panels: left = timer + controls, right = skill editor. CSS Grid or Flexbox.
6. **No JS for breakpoints**—media queries only.
7. **Test** at 375px, 768px, 1024px, 1440px.

If any requirement conflicts with existing code, prefer **updating the code to match this spec**. Document any deviation in the next architecture pass.
